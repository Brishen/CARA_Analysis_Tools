import unittest
import numpy as np
from DistributedPython.ProbabilityOfCollision.PcMultiStep import PcMultiStep

class TestPcMultiStep(unittest.TestCase):

    def test_pri_default_cov(self):
        # r1, v1, r2, v2, C2, HBR from properties (sample data)
        # Using placeholder values for others
        r1 = np.array([-9.841950433215101e+05, +3.932342044549424e+05, +6.991223682230414e+06])
        v1 = np.array([+4.883696742000000e+03, +5.689086045000000e+03, +3.665361590000000e+02])
        r2 = np.array([-9.839696058965517e+05, +3.936845951174244e+05, +6.991219291625473e+06])
        v2 = np.array([+1.509562687000000e+03, +7.372938617000000e+03, -1.492509430000000e+02])
        C2 = np.eye(6)
        HBR = 20.0

        sigmaValSq = (6378135 * 10)**2
        localC1 = np.zeros((6, 6))
        localC1[0, 0] = sigmaValSq
        localC1[1, 1] = sigmaValSq
        localC1[2, 2] = sigmaValSq

        Pc, out = PcMultiStep(r1, v1, localC1, r2, v2, C2, HBR)

        self.assertTrue(np.isnan(Pc))
        self.assertIn('Primary Cov >= Default Covariance Cutoff', out['PcMethod'])

    def test_pri_cov_neg_variance(self):
        r1 = np.array([7000e3, 0, 0])
        v1 = np.array([0, 7.5e3, 0])
        r2 = np.array([7000e3 + 10, 0, 0])
        v2 = np.array([0, 7.5e3, 0])
        C2 = np.eye(6)
        HBR = 10.0

        sigmaValSq = -1.0
        localC1 = np.zeros((6, 6))
        localC1[0, 0] = sigmaValSq
        localC1[1, 1] = sigmaValSq
        localC1[2, 2] = sigmaValSq

        Pc, out = PcMultiStep(r1, v1, localC1, r2, v2, C2, HBR)

        self.assertTrue(np.isnan(Pc))
        self.assertIn('Primary Cov has negative sigma^2 value', out['PcMethod'])

    def test_similar_to_2d_via_multistep(self):
        # Should execute Pc2D if no violations, or Nc2D/Nc3D if violations.
        # This case is well behaved, so likely Pc2D.

        expSolution = 1.0289973e-02
        Accuracy = 0.001

        r1 = np.array([-9.841950433215101e+05, +3.932342044549424e+05, +6.991223682230414e+06])
        v1 = np.array([+4.883696742000000e+03, +5.689086045000000e+03, +3.665361590000000e+02])

        cov1 = np.array([
            [+4.976545641899520e+04, +5.787130862568278e+04, +3.370410320935015e+03, +1.137272273949272e+01, -4.325472616114674e+00, -8.009705480233521e+01],
            [+5.787130862568278e+04, +6.730377643610841e+04, +3.926542932121541e+03, +1.321992688238858e+01, -5.035560720747812e+00, -9.314985106902773e+01],
            [+3.370410320935015e+03, +3.926542932121541e+03, +2.461403197221289e+02, +7.586865834476763e-01, -3.077848629905763e-01, -5.434034460756914e+00],
            [+1.137272273949272e+01, +1.321992688238858e+01, +7.586865834476763e-01, +2.608186227148725e-03, -9.804181796720670e-04, -1.829751672999786e-02],
            [-4.325472616114674e+00, -5.035560720747812e+00, -3.077848629905763e-01, -9.804181796720670e-04, +3.895883508545853e-04, +6.968892326415779e-03],
            [-8.009705480233521e+01, -9.314985106902773e+01, -5.434034460756914e+00, -1.829751672999786e-02, +6.968892326415779e-03, +1.289253320300791e-01]
        ])

        r2 = np.array([-9.839696058965517e+05, +3.936845951174244e+05, +6.991219291625473e+06])
        v2 = np.array([+1.509562687000000e+03, +7.372938617000000e+03, -1.492509430000000e+02])

        cov2 = np.array([
            [+4.246862551076427e+04, +2.066374367781032e+05, -5.011108933888592e+03, +3.104606531932427e+01, -1.201093683199582e+01, -2.207975848324051e+02],
            [+2.066374367781032e+05, +1.005854717283451e+06, -2.434876491048039e+04, +1.510022508670080e+02, -5.850063541467530e+01, -1.074752763805685e+03],
            [-5.011108933888592e+03, -2.434876491048039e+04, +6.131274993037449e+02, -3.667147183233717e+00, +1.391769957262238e+00, +2.601457791444154e+01],
            [+3.104606531932427e+01, +1.510022508670080e+02, -3.667147183233717e+00, +2.272826228568773e-02, -8.778253314778023e-03, -1.613538091053610e-01],
            [-1.201093683199582e+01, -5.850063541467530e+01, +1.391769957262238e+00, -8.778253314778023e-03, +3.428801115804722e-03, +6.251148178133809e-02],
            [-2.207975848324051e+02, -1.074752763805685e+03, +2.601457791444154e+01, -1.613538091053610e-01, +6.251148178133809e-02, +1.148404222181769e+00]
        ])

        HBR = 20

        # Test without cross correlation corrections to match the 3D test setup if needed?
        # The 3D test setup used cross correlation in one case and not in another.
        # Here we use default params (apply_covXcorr_corrections=True).
        # But this data might not have DCP params available/set correctly?
        # get_covXcorr_parameters defaults to False if params missing.
        # Actually default_params sets it to True.
        # But get_covXcorr_parameters checks if fields exist.

        Pc, out = PcMultiStep(r1, v1, cov1, r2, v2, cov2, HBR)

        # We expect a value close to expSolution.
        # And we expect PcMethod to be '2D-Pc' or something valid.
        print(f"Computed Pc: {Pc}, Method: {out['PcMethod']}")
        self.assertTrue(np.isclose(Pc, expSolution, rtol=Accuracy))

    def test_force_nc3d(self):
        # Use same data but force Nc3D
        expSolution = 1.0289973e-02
        Accuracy = 0.001

        r1 = np.array([-9.841950433215101e+05, +3.932342044549424e+05, +6.991223682230414e+06])
        v1 = np.array([+4.883696742000000e+03, +5.689086045000000e+03, +3.665361590000000e+02])

        cov1 = np.array([
            [+4.976545641899520e+04, +5.787130862568278e+04, +3.370410320935015e+03, +1.137272273949272e+01, -4.325472616114674e+00, -8.009705480233521e+01],
            [+5.787130862568278e+04, +6.730377643610841e+04, +3.926542932121541e+03, +1.321992688238858e+01, -5.035560720747812e+00, -9.314985106902773e+01],
            [+3.370410320935015e+03, +3.926542932121541e+03, +2.461403197221289e+02, +7.586865834476763e-01, -3.077848629905763e-01, -5.434034460756914e+00],
            [+1.137272273949272e+01, +1.321992688238858e+01, +7.586865834476763e-01, +2.608186227148725e-03, -9.804181796720670e-04, -1.829751672999786e-02],
            [-4.325472616114674e+00, -5.035560720747812e+00, -3.077848629905763e-01, -9.804181796720670e-04, +3.895883508545853e-04, +6.968892326415779e-03],
            [-8.009705480233521e+01, -9.314985106902773e+01, -5.434034460756914e+00, -1.829751672999786e-02, +6.968892326415779e-03, +1.289253320300791e-01]
        ])

        r2 = np.array([-9.839696058965517e+05, +3.936845951174244e+05, +6.991219291625473e+06])
        v2 = np.array([+1.509562687000000e+03, +7.372938617000000e+03, -1.492509430000000e+02])

        cov2 = np.array([
            [+4.246862551076427e+04, +2.066374367781032e+05, -5.011108933888592e+03, +3.104606531932427e+01, -1.201093683199582e+01, -2.207975848324051e+02],
            [+2.066374367781032e+05, +1.005854717283451e+06, -2.434876491048039e+04, +1.510022508670080e+02, -5.850063541467530e+01, -1.074752763805685e+03],
            [-5.011108933888592e+03, -2.434876491048039e+04, +6.131274993037449e+02, -3.667147183233717e+00, +1.391769957262238e+00, +2.601457791444154e+01],
            [+3.104606531932427e+01, +1.510022508670080e+02, -3.667147183233717e+00, +2.272826228568773e-02, -8.778253314778023e-03, -1.613538091053610e-01],
            [-1.201093683199582e+01, -5.850063541467530e+01, +1.391769957262238e+00, -8.778253314778023e-03, +3.428801115804722e-03, +6.251148178133809e-02],
            [-2.207975848324051e+02, -1.074752763805685e+03, +2.601457791444154e+01, -1.613538091053610e-01, +6.251148178133809e-02, +1.148404222181769e+00]
        ])

        HBR = 20
        params = {'ForceNc3DCalculation': True}

        Pc, out = PcMultiStep(r1, v1, cov1, r2, v2, cov2, HBR, params)

        print(f"Computed Pc: {Pc}, Method: {out['PcMethod']}")
        self.assertTrue(np.isclose(Pc, expSolution, rtol=Accuracy))
        self.assertIn('3D-Nc', out['PcMethod'])

if __name__ == '__main__':
    unittest.main()
